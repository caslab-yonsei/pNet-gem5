#!/bin/bash
# Authors: Mohammad Alian <malian2@illinois.edu>
# boot gem5 and take a checkpoint
#
# The idea of this script is the same as
# "configs/boot/hack_back_ckpt.rcS" by Joel Hestness
# Please look into that for more info
#
source /root/.bashrc

#THIS IS WHERE EXECUTION BEGINS FROM AFTER RESTORING FROM CKPT
if [ "$RUNSCRIPT_VAR" -eq 2 ]
then
    ncpu=$(grep -c processor /proc/cpuinfo)
	cd /home/benchmark/mutilate
    echo "Before running"
    cat /proc/interrupts
	cat /proc/stat

    echo "Start Bench"
    for((i=1; i <$ncpu ; i++)) do
		taskset -c $i ./mutilate -s 192.168.0.2:$(expr 11211 + $i) --affinity --loadonly -T 1 -r 100000 &
	done
    taskset -c 0 ./mutilate -s 192.168.0.2:11211 --affinity --loadonly -T 1 -r 100000
    echo "resetstats"
    /sbin/m5 resetstats 0
    for((i=0; i <$ncpu ; i++)) do
		taskset -c $i ./mutilate -s 192.168.0.2:$(expr 11211 + $i) -t 1 -T 1 --affinity --noload -r 100000 &
	done
    for((time=0 ; time < 30; time++)) do
		cat /proc/interrupts
		cat /proc/stat
		sleep 0.1
	done
	/sbin/m5 exit 1
fi

# Retrieve dist-gem5 rank and size parameters using the 'm5' utility
MY_RANK=$(/sbin/m5 initparam dist-rank)
[ $? = 0 ] || { echo "m5 initparam failed"; exit -1; }
MY_SIZE=$(/sbin/m5 initparam dist-size)
[ $? = 0 ] || { echo "m5 initparam failed"; exit -1; }


echo "***** Start boot script! *****"
if [ "${RUNSCRIPT_VAR+set}" != set ]
then
    # Signal our future self that it's safe to continue
    echo "RUNSCRIPT_VAR not set! Setting it ..."
    export RUNSCRIPT_VAR=1
else
    echo "RUNSCRIPT_VAR is set!"
        # We've already executed once, so we should exit
        echo "calling m5 exit ..."
        /sbin/m5 exit 1
fi

/bin/hostname node${MY_RANK}

# Keep MAC address assignment simple for now ...
(($MY_RANK > 97)) && { echo "(E) Rank must be less than 98"; /sbin/m5 abort; }
((MY_ADDR = MY_RANK + 2))
if (($MY_ADDR < 10))
then
    MY_ADDR_PADDED=0${MY_ADDR}
else
    MY_ADDR_PADDED=${MY_ADDR}
fi

insmod /home/nepu1000.ko

/sbin/ifconfig eth0 hw ether 00:90:00:00:00:${MY_ADDR_PADDED}
/sbin/ifconfig eth0 192.168.0.${MY_ADDR} netmask 255.255.255.0 up

/sbin/ifconfig -a

# take a checkpoint
if [ "$MY_RANK" == "0" ]
then
    /sbin/m5 checkpoint 1
else
    sleep 0.01
fi

if ((MY_RANK < 1))
then
	for((i=0; i < 4; i++)) do
		let core=2**$i
		hex_core=$(printf "%x" $core)                                                                                                                                                               
		echo $hex_core > /proc/irq/$(expr 15 + $i)/smp_affinity
		echo $i > /proc/irq/$(expr 15 + $i)/smp_affinity_list
		echo $i > /proc/irq/$(expr 15 + $i)/smp_affinity_list
		echo $hex_core > /proc/irq/$(expr 15 + $i)/smp_affinity
		cat /proc/irq/$(expr 15 + $i)/smp_affinity_list
		cat /proc/irq/$(expr 15 + $i)/smp_affinity
	done
	ncpu=$(grep -c processor /proc/cpuinfo)
	echo $ncpu
	cd /home/memcached-1.6.9
	for((i=0; i < $ncpu ; i++)) do
		taskset -c $i ./memcached -m $(expr 2048 "/" $ncpu) -p $(expr 11211 + $i) -l 192.168.0.${MY_ADDR} -t 1 -u root &
	done
	/sbin/m5 resetstats 0
	for((time=0; time<1000; time++)) do
		cat /proc/interrupts
		cat /proc/stat
		sleep 0.1
	done
else
	for((i=0; i < 4; i++)) do
		let core=2**$i
		hex_core=$(printf "%x" $core)                                                                                                                                                               
		echo $hex_core > /proc/irq/$(expr 15 + $i)/smp_affinity
		echo $i > /proc/irq/$(expr 15 + $i)/smp_affinity_list
		echo $i > /proc/irq/$(expr 15 + $i)/smp_affinity_list
		echo $hex_core > /proc/irq/$(expr 15 + $i)/smp_affinity
		cat /proc/irq/$(expr 15 + $i)/smp_affinity_list
		cat /proc/irq/$(expr 15 + $i)/smp_affinity
	done

	ncpu=$(grep -c processor /proc/cpuinfo)
	cd /home/benchmark/mutilate
	sleep 2
    export RUNSCRIPT_VAR=2
    /sbin/m5 checkpoint 1
    /sbin/m5 readfile > /tmp/runscript1.sh
    /bin/bash /tmp/runscript1.sh
    /sbin/m5 exit 1

	for((i=1; i <$ncpu ; i++)) do
		taskset -c $i ./mutilate -s 192.168.0.2:$(expr 11211 + $i) --affinity --loadonly -T 1 -r 100000 &
	done
	taskset -c 0 ./mutilate -s 192.168.0.2:11211 --affinity --loadonly -T 1 -r 100000
	/sbin/m5 resetstats 0
	for((i=0; i <$ncpu ; i++)) do
		taskset -c $i ./mutilate -s 192.168.0.2:$(expr 11211 + $i) -t 1 -T 1 --affinity --noload -r 100000 &
	done
	for((time=0 ; time < 30; time++)) do
		cat /proc/interrupts
		cat /proc/stat
		sleep 0.1
	done
	/sbin/m5 exit 1
fi

#THIS IS WHERE EXECUTION BEGINS FROM AFTER RESTORING FROM CKPT
if [ "$RUNSCRIPT_VAR" -eq 1 ]
then
    # Signal our future self not to recurse infinitely
    export RUNSCRIPT_VAR=2
    # Read the script for the checkpoint restored execution
    echo "Loading new script..."
    /sbin/m5 readfile > /tmp/runscript1.sh

    # Execute the new runscript
    if [ -s /tmp/runscript1.sh ]
    then
        /bin/bash /tmp/runscript1.sh
    else
        echo "Script not specified"
    fi
fi

echo "Fell through script. Exiting ..."
/sbin/m5 exit 1

